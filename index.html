<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>수박 게임</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: #f0ebe1;
      font-family: 'Segoe UI', sans-serif;
      touch-action: none;
    }
    #ui {
      position: absolute;
      top: 5px; width: 100%; text-align: center;
      z-index: 10;
    }
    #score {
      font-size: 22px; font-weight: bold; color: #333;
    }
    #previewWrapper {
      margin-top: 8px;
      display: flex; justify-content: center;
    }
    #preview {
      border: 2px solid #aaa;
      border-radius: 50%;
      transition: all 0.15s ease;
    }
    #gameOver {
      position: absolute; top:50%; left:50%;
      transform: translate(-50%,-50%);
      background: white;
      padding: 20px;
      border-radius:10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      text-align:center;
      font-size: 24px;
      display: none;
      z-index: 20;
    }
    canvas {
      display: block;
      margin: 60px auto 0;
      background: #fffbe6;
      border-radius: 10px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">Score: 0</div>
    <div id="previewWrapper">
      <canvas id="preview" width="60" height="60"></canvas>
    </div>
  </div>
  <canvas id="gameCanvas" width="360" height="600"></canvas>
  <div id="gameOver">게임 오버!<br>🔄 새로고침해서 다시 시작</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

    // 물리 엔진 설정
    const engine = Engine.create();
    const world = engine.world;
    const canvas = document.getElementById("gameCanvas");
    const render = Render.create({
      element: document.body,
      canvas,
      engine,
      options: {
        width: 360, height: 600, wireframes: false, background: "#fffbe6"
      }
    });
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // 벽 설정
    World.add(world, [
      Bodies.rectangle(180, 600, 360, 20, { isStatic: true }),
      Bodies.rectangle(0, 300, 20, 600, { isStatic: true }),
      Bodies.rectangle(360, 300, 20, 600, { isStatic: true })
    ]);

    // 과일 데이터
    const colors = ["#FF6B6B", "#FFD93D", "#6BCB77", "#4D96FF", "#C780FA", "#FFA07A", "#00CED1", "#FF69B4"];
    const sizes = [14, 18, 22, 26, 32, 38, 46, 54];
    const scores = [10,20,40,80,160,300,600,1000];

    let fruits = [], score = 0;
    let currentType = randomType(), nextType = randomType();

    // UI 요소
    const scoreDiv = document.getElementById("score");
    const previewCanvas = document.getElementById("preview");
    const previewCtx = previewCanvas.getContext("2d");
    const gameOverDiv = document.getElementById("gameOver");

    function randomType() {
      return Math.floor(Math.random()*3);
    }

    function drawPreview() {
      const ctx = previewCtx;
      const r = sizes[nextType];
      ctx.clearRect(0,0,60,60);
      ctx.beginPath();
      ctx.arc(30,30,r,0,2*Math.PI);
      ctx.fillStyle = colors[nextType];
      ctx.fill();
    }
    drawPreview();

    // 과일 생성
    function spawnFruit(x) {
      const type = currentType;
      const body = Bodies.circle(x, -20, sizes[type], {
        restitution: 0.25, friction: 0.01,
        render: { fillStyle: colors[type] }
      });
      body.fruitType = type;
      fruits.push(body);
      World.add(world, body);

      currentType = nextType;
      nextType = randomType();
      drawPreview();
    }

    // 병합 로직
    function mergeFruits() {
      for(let i=0;i<fruits.length;i++){
        const a = fruits[i]; if(!a) continue;
        for(let j=i+1;j<fruits.length;j++){
          const b = fruits[j]; if(!b||a.fruitType!==b.fruitType) continue;
          const dx=a.position.x-b.position.x, dy=a.position.y-b.position.y;
          const dist=Math.hypot(dx,dy);
          const min = a.circleRadius + b.circleRadius;
          if(dist<min*0.8){
            const nt=a.fruitType+1;
            if(nt>=sizes.length) continue;
            const body = Bodies.circle((a.position.x+b.position.x)/2,(a.position.y+b.position.y)/2,sizes[nt],{
              restitution:0.25, friction:0.01,
              render:{ fillStyle: colors[nt] }
            });
            body.fruitType = nt;
            World.add(world, body);
            fruits.push(body);

            World.remove(world, a);
            World.remove(world, b);
            fruits[i]=null; fruits[j]=null;

            score += scores[nt];
            scoreDiv.textContent = "Score: "+score;
            return;
          }
        }
      }
    }

    Events.on(engine, "afterUpdate",()=>{
      mergeFruits();
      for(const f of fruits){
        if(f && f.position.y < -50){
          gameOverDiv.style.display = "block";
          Runner.stop(engine);
          break;
        }
      }
    });

    // 터치/클릭 처리
    function onPointerDown(e){
      const x = e.clientX || (e.touches&&e.touches[0].clientX);
      if(!x) return;
      const rect = canvas.getBoundingClientRect();
      spawnFruit(x - rect.left);
    }
    canvas.addEventListener("pointerdown", onPointerDown);

  </script>
</body>
</html>
