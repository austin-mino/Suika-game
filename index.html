<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>수박 게임 - 미니멀 버전</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #faf8ef;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      font-weight: bold;
      color: #333;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      background: rgba(255,255,255,0.95);
      padding: 20px;
      border-radius: 12px;
      display: none;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="gameOver">Game Over!<br>새로고침해서 다시 시작하세요</div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, World, Events, Body } = Matter;

    const canvas = document.getElementById('gameCanvas');
    const engine = Engine.create();
    const world = engine.world;

    const render = Render.create({
      canvas,
      engine,
      options: {
        width: 400,
        height: 600,
        wireframes: false,
        background: '#faf8ef',
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // 벽과 바닥
    const walls = [
      Bodies.rectangle(200, 600, 400, 20, { isStatic: true }), // 바닥
      Bodies.rectangle(0, 300, 20, 600, { isStatic: true }), // 왼쪽
      Bodies.rectangle(400, 300, 20, 600, { isStatic: true }) // 오른쪽
    ];
    World.add(world, walls);

    const fruitColors = [
      "#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF",
      "#D7BAFF", "#FFBAED", "#FFCBA4", "#C4FAF8", "#B5FBA5"
    ];
    const fruitSizes = [16, 20, 24, 28, 32, 36, 40, 44, 48, 52]; // 반지름
    const fruitScores = [10, 20, 30, 40, 60, 80, 100, 120, 150, 200];

    const fruits = [];
    let currentType = 0;
    let score = 0;

    const scoreDiv = document.getElementById("score");
    const gameOverDiv = document.getElementById("gameOver");

    function spawnFruit(x) {
      const r = fruitSizes[currentType];
      const fruit = Bodies.circle(x, 0, r, {
        restitution: 0.2,
        friction: 0.01,
        render: { fillStyle: fruitColors[currentType] }
      });
      fruit.fruitType = currentType;
      fruits.push(fruit);
      World.add(world, fruit);
      currentType = Math.floor(Math.random() * 3);
    }

    function mergeFruits() {
      for (let i = 0; i < fruits.length; i++) {
        const a = fruits[i];
        if (!a) continue;
        for (let j = i + 1; j < fruits.length; j++) {
          const b = fruits[j];
          if (!b || a.fruitType !== b.fruitType) continue;

          const dx = a.position.x - b.position.x;
          const dy = a.position.y - b.position.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = a.circleRadius + b.circleRadius;

          if (dist < minDist * 0.9) {
            // 병합
            const newType = a.fruitType + 1;
            if (newType >= fruitSizes.length) return;

            const newRadius = fruitSizes[newType];
            const newFruit = Bodies.circle((a.position.x + b.position.x)/2, (a.position.y + b.position.y)/2, newRadius, {
              restitution: 0.2,
              friction: 0.01,
              render: { fillStyle: fruitColors[newType] }
            });
            newFruit.fruitType = newType;

            World.remove(world, a);
            World.remove(world, b);
            fruits[i] = null;
            fruits[j] = null;
            fruits.push(newFruit);
            World.add(world, newFruit);

            score += fruitScores[newType];
            scoreDiv.textContent = `Score: ${score}`;
            return;
          }
        }
      }
    }

    Events.on(engine, 'afterUpdate', () => {
      mergeFruits();

      for (const f of fruits) {
        if (f && f.position.y < 0) {
          gameOverDiv.style.display = "block";
          Runner.stop(runner);
          break;
        }
      }
    });

    // 마우스 & 터치 입력
    function handleInput(e) {
      const x = e.touches ? e.touches[0].clientX : e.clientX;
      const rect = canvas.getBoundingClientRect();
      spawnFruit(x - rect.left);
    }

    canvas.addEventListener("mousedown", handleInput);
    canvas.addEventListener("touchstart", handleInput);
  </script>
</body>
</html>
